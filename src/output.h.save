#ifndef CHRONO_OUTPUT
#define CHRONO_OUTPUT

//Defines for strdup
#ifdef __STDC_ALLOC_LIB__
#define __STDC_WANT_LIB_EXT2__ 1
#else
#define _POSIX_C_SOURCE 200809L
#endif

#include <unistd.h>
#include <string.h>
#include <stdio.h>

#include "terminal.h"
#include "append_buffer.h"
#include "chrono.h"

#define LOGOLINES 7

char *logo =
"    ___       ___       ___       ___       ___       ___   \r\n"
"   /\\  \\     /\\__\\     /\\  \\     /\\  \\     /\\__\\     /\\  \\  \r\n"
"  /::\\  \\   /:/__/_   /::\\  \\   /::\\  \\   /:| _|_   /::\\  \\ \r\n"
" /:/\\:\\__\\ /::\\/\\__\\ /::\\:\\__\\ /:/\\:\\__\\ /::|/\\__\\ /:/\\:\\__\\\r\n"
" \\:\\ \\/__/ \\/\\::/  / \\;:::/  / \\:\\/:/  / \\/|::/  / \\:\\/:/  /\r\n"
"  \\:\\__\\     /:/  /   |:\\/__/   \\::/  /    |:/  /   \\::/  / \r\n"
"   \\/__/     \\/__/     \\|__|     \\/__/     \\/__/     \\/__/";

/* output  */
void editorDrawRows(struct abuf *ab) {
    int y;
    for(y = 0; y < E.screenrows; y++) {
        appendBuf(ab, "~", 1);

        appendBuf(ab, "\x1b[K", 3);
        if(y < E.screenrows - 1) {
            appendBuf(ab, "\r\b", 2);
        }
    }
}

int getLogoMaxWidth() {
    int maxWidth = 0;
    int y = 0;
    for(int i = 0, size = strlen(logo); i < size; i++) {
        if(logo[i] == '\r') {
            if(maxWidth < y) maxWidth = y;
            y = 0;
        } else {
            y++;
        }
    }

    if(maxWidth < y) maxWidth = y;
    return maxWidth;
}

void drawWelcome(struct abuf *ab) {
    int newLogoRows = 0;
    int logoWidth = getLogoMaxWidth();

    int padding = (E.screencols - logoWidth) / 2;
    if(padding < 0) padding = 0;

    int verticalPadding = (2 * E.screenrows) / 5;

    // Format the string with padding:
    int newSize = strlen(logo) + LOGOLINES + (padding + 1) + verticalPadding * (E.screencols + 2) + 1;
    char *newLogo = malloc(newSize);
    if(newLogo == NULL) die("NewLogo");

    newLogo[0] = '\0';

    // Add vertical padding
    for (int i = 0; i < verticalPadding; ++i) {
        for (int j = 0; j < E.screencols; ++j) {
            strcat(newLogo, " "); // Fill the line with spaces
        }
        strcat(newLogo, "\r\n"); // Add newline at the end of each padded line
    }

    // Duplicating the logo string so the original doesn't get modified
    char *logoCopy = strdup(logo);
    if(logoCopy == NULL) { free(newLogo); die("NewLogo"); }

    // Buffer to hold one line of the padded logo
    char *lineBuffer = malloc(E.screencols + 2);
    if(lineBuffer == NULL) { free(newLogo); free(logoCopy); die("NewLogo"); }

    char *line = strtok(logoCopy, "\n");
    while(line != NULL) {
        newLogoRows++;

        // Reset the line and fill it with spaces for padding
        memset(lineBuffer, ' ', E.screencols);
        lineBuffer[E.screencols] = '\0';

        // Copy the logo line into the buffer at the right offset
        strncpy(lineBuffer + padding, line, strlen(line));

        // Ensure the line ends with a newline Character
        lineBuffer[padding + strlen(line)] = '\r';
        lineBuffer[padding + strlen(line) + 1] = '\n';
        lineBuffer[padding + strlen(line) + 2] = '\0';

        // Prints the line buffer to the terminal
        appendBuf(ab, lineBuffer, strlen(lineBuffer));

        // Append the new logo
        strcat(newLogo, lineBuffer);
        line = strtok(NULL, "\n");
    }
    free(lineBuffer);
    free(logoCopy);
    free(newLogo);

    for(int i = newLogoRows - 1; i < E.screenrows; i++) {
        appendBuf(ab, "\r\n", 2);
    }
}

void editorRefreshScreen() {
    struct abuf ab = ABUF_INIT;

    appendBuf(&ab, "\x1b[?25l", 6); // Hides the cursor
    appendBuf(&ab, "\x1b[H", 3); // Moves the cursor to the top left position

    drawWelcome(&ab);

    appendBuf(&ab, "\x1b[H", 3);
    appendBuf(&ab, "\x1b[?25h", 6); // Displays the cursor again

    write(STDIN_FILENO, ab.buf, ab.len);
    freeBuf(&ab);
}

#endif // CHRONO_OUTPUT
